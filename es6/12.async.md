# 12.async函数

---

ES2017引入了async函数，使异步操作变得更加方便。

async函数是什么，其实就是Generator函数的语法糖。

```js
var fs = require('fs');
var readFile = function(filename) {
	return new Promise(function(resolve, reject) {
		fs.readFile(fileName, function(error, data) {
			if (error) reject(error);
			resolve(data);
		})
	})
}
var gen = function*() {
	var f1 = yield readFile('./etc/fstab');
	var f2 = yield readFile('./etc/shells');
	console.log(f1.toString());
	console.log(f2.toString());
}

/*写成async函数*/
var asyncReadFile = async function() {
	var f1 = await readFile('./etc/fstab');
	var f2 = await readFile('./etc/shells');
	console.log(f1.toString());
	console.log(f2.toString());
}
```

`async`函数对 Generator 函数的改进，体现在以下四点。

（1）内置执行器。

Generator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。

```js
var result = asyncReadFile();
```

上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。

（2）更好的语义。

`async`和`await`，比起星号和`yield`，语义更清楚了。`async`表示函数里有异步操作，`await`表示紧跟在后面的表达式需要等待结果。

（3）更广的适用性。

`co`模块约定，`yield`命令后面只能是 Thunk 函数或 Promise 对象，而`async`函数的`await`命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。

（4）返回值是 Promise。

`async`函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用`then`方法指定下一步的操作。

进一步说，`async`函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而`await`命令就是内部`then`命令的语法糖。

