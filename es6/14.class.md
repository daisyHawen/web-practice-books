# 14.Class的继承

---

### 基本用法 {#基本用法}

Class之间可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多

```js
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类没有自己的`this`对象，而是继承父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类就得不到`this`对象。

### 类的prototype属性和\_\_proto\_\_属性 {#类的prototype属性和__proto__属性}

大多数浏览器的ES5实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。

（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。

（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。

接上面的代码：

```js
console.log(cp.__proto__);//ColorPoint {}
```

## 原生构造函数的继承 {#原生构造函数的继承}

原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。

* Boolean\(\)
* Number\(\)
* String\(\)
* Array\(\)
* Date\(\)
* Function\(\)
* RegExp\(\)
* Error\(\)
* Object\(\)

以前，这些原生构造函数是无法继承的，比如，不能自己定义一个`Array`的子类。

ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。下面是一个继承`Array`的例子。

## Class 的 Generator 方法 {#Class-的-Generator-方法}

如果某个方法之前加上星号（`*`），就表示该方法是一个 Generator 函数。

