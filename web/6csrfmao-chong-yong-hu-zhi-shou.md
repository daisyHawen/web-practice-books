# 6.CSRF:冒充用户之手

---

CSRF和XSS根本是两个不同维度上的分类。XSS是实现CSRF的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过XSS来实现的CSRF称为XSRF。

CSRF的全称是“跨站请求伪造”，而XSS的全称是“跨站脚本”。它们都是属于**跨站攻击——不攻击服务器而攻击正常访问网站的用户。**

CSRF顾名思义，是伪造请求，冒充用户在站内的正常操作：绝大多数网站是通过cookie等方式辨识用户身份（包括服务器端Session的网站，因为SessionID也是大多保存在cookie里面的），再予授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途经，让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。

CSRF不能分类为注入攻击，因为CSRF的实现途径远远不止XSS注入一条。通过XSS来实现CSRF易如反掌，但对于设计不佳的网站，一条正常的链接都能造成CSRF。

因为请求可以从任何一方发起，而发起请求的方式多种多样，可以通过 iframe、ajax（这个不能跨域，得先 XSS）、Flash 内部发起请求（总是个大隐患）。由于几乎没有彻底杜绝 CSRF 的方式，我们一般的做法，是以各种方式提高攻击的门槛。

## 应对方案

---

#### 1.改良站内API设计

改良站内API设计，对于发布帖子这一类创建资源的操作，应该只接受POST请求，而GET请求应该只浏览而不改变服务器端资源。

当然最理想的做法是采用REST风格的API设计，GET、POST、PUT、DELETE四种请求方法对应资源的读取、创建、修改、删除。

然而现在的浏览器基本不支持在表单中使用PUT和DELETE请求方法，我们可以用ajax提交请求，也可以使用隐藏域指定请求方法，然后用POST模拟PUT和DELETE请求方法。这么一来，不同的资源操作区分的非常清楚，我们把问题域缩小到了非GET类型的请求——攻击者已经不可能通过发布链接来伪造请求了，但他们仍然可以发布表单，或者在其他站点上使用我们肉眼不可见的表单，在后台用js操作，伪造请求。

#### 2.采用“请求令牌”

“请求令牌”和“同步令牌”原理是一样的，只不过目的不同，后者是为了解决POST请求重复提交问题，前者是为了保证收到的请求一定来自预期的页面。

实现的方式也很简单，首先服务器要以某种策略生成随机字符串，作为令牌Token，保存在session里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收的信息中的令牌与Session中的令牌比较，只有一致的时候才处理请求，否则返回HTTP 403拒绝请求或者要求用户重新登录验证身份。

请求令牌虽然使用起来简单，但并非不可破解，使用不当会增加安全隐患。使用请求令牌来防止CSRF有以下几点要注意：

* 虽然请求令牌原理和验证码有相似之处，但不应该像验证码一样，全局使用一个 Session Key。因为请求令牌的方法在理论上是可破解的，破解方式是解析来源页面的文本，获取令牌内容。如果全局使用一个 Session Key，那么危险系数会上升。原则上来说，每个页面的请求令牌都应该放在独立的 Session Key 中。我们在设计服务器端的时候，可以稍加封装，编写一个令牌工具包，将页面的标识作为 Session 中保存令牌的键。

* 在 ajax 技术应用较多的场合，因为很有请求是 JavaScript 发起的，使用静态的模版输出令牌值或多或少有些不方便。但无论如何，请不要提供直接获取令牌值的 API。这么做无疑是锁上了大门，却又把钥匙放在门口，让我们的请求令牌退化为同步令牌。

* 第一点说了请求令牌理论上是可破解的，所以非常重要的场合，应该考虑使用验证码（令牌的一种升级，目前来看破解难度极大），或者要求用户再次输入密码（亚马逊、淘宝的做法）。但这两种方式用户体验都不好，所以需要产品开发者权衡。

* 无论是普通的请求令牌还是验证码，**服务器端验证过一定记得销毁**。忘记销毁用过的令牌是个很低级但是杀伤力很大的错误。我们学校的选课系统就有这个问题，验证码用完并未销毁，故只要获取一次验证码图片，其中的验证码可以在多次请求中使用（只要不再次刷新验证码图片），一直用到 Session 超时。这也是为何选课系统加了验证码，外挂软件升级一次之后仍然畅通无阻。

#### 3.如下也列出一些据说能有效防范 CSRF，其实效果甚微的方式甚至无效的做法。

* 通过 referer 判定来源页面：referer 是在 HTTP Request Head 里面的，也就是由请求的发送者决定的。如果我喜欢，可以给 referer 任何值。当然这个做法并不是毫无作用，起码可以防小白。但我觉得性价比不如令牌。

* 过滤所有用户发布的链接：这个是最无效的做法，因为首先攻击者不一定要从站内发起请求（上面提到过了），而且就算从站内发起请求，途径也远远不止链接一条。比如&lt;img src="./create\_post.php"/&gt;就是个不错的选择，还不需要用户去点击，只要用户的浏览器会自动加载图片，就会自动发起请求。

* 在请求发起页面用 alert 弹窗提醒用户：这个方法看上去能干扰站外通过 iframe 发起的 CSRF，但攻击者也可以考虑用window.alert =function\(\){}; 把 alert 弄哑，或者干脆脱离 iframe，使用 Flash 来达到目的。

---

参考：https://blog.tonyseek.com/post/introduce-to-xss-and-csrf/

